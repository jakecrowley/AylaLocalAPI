# Ayla IoT Local API AES key exchange 

App sends `GET` to `http://<IoT_device_ip>/local_reg.json`

Device responds with JSON object
`POST` @ `http://<iOS_device_ip>/local_lan/key_exchange.json`  
example body
```
{
   "key_exchange":{
      "ver":1,
      "random_1": (random 16 char string),
      "time_1": (current epoch in microseconds),
      "proto":1,
      "key_id":1234
   }
}
```
`handleKeyExchange` is then called by the app to process the key exchange

***

## `-[AylaLanModule:handleKeyExchange:] `
generates `random_2` and retrieves current time for `time_2`  
calls `setVersion`, `setProto1`, and `setKeyId1` with the values from the JSON object

checks if `ver` and `proto` are 1, 
retrieves the global `AylaLanConfig` object   
then initializes a new `AylaEncryptionConfig` object and copies data to it

checks if `sessionType` is 1, then calls `generateSessionkeys` (which im assuming is the function that actually does all the important stuff) with `random_1`, `time_1`, `random_2`, and `time_2`

generates an `AylaHTTPResponse` with body `{"random_2": r2, "time_2": t2}` and responds to the IoT device.

***

## `-[generateSessionkeys:sRnd1:nTime1:sRnd2:nTime2:]`
calls `setSRnd1`, `setNTime1`, `setSRnd2`, and `setNTime2` with according parameters

encodes `sRnd1` and `sRnd2` into an `NSData` object with encoding type `0x4` (UTF-8)

checks if `AylaEncryptionConfig` type is `LAN`  
gets `lanipKey` from `AylaEncryptionConfig` object  
> lanipKey is retrieved from the Ayla API (presumably during wifi setup which may be implemented in the future) endpoint at `https://ads-field.aylanetworks.com/apiv1/devices/{device_id}/lan.json`.  
Implementation for this retrieval can be found in `get_devices.py`.

calls `setSLanKey` to `lanipKey`  
calls `setBLanKey` to `NSData` encoded `lanipKey`

converts `time_1` and `time_2` to strings  
encodes both strings into `NSData` objects with UTF-8

allocates and initializes an empty `NSMutableData` object   
appends `sRnd1` -> `sRnd2` -> `time_1` -> `time_2` -> `'0'` 

appends `'0'` for `AppSignKey`, `'1'` for `AppCryptoKey`, or `'2'` for `AppIvSeed`

for each of the App variables, it calls `hmacForKey` (standard HMAC with SHA256 digest) with `bLanKey` as the key and previously created `NSMutableData` object  
result of the HMAC is prepended to the data and `hmacForKey` is called again with the new data object
result of the HMAC is saved in the corresponding global variable

`eCipher` is new `CCCryptor` object is created and initalized with algorithm `AES-128-ECB`  
AppCryptoKey as the key, and AppIvSeed as the IV and stores in the variable  

`dCipher` is new `CCCryptor` object is created the same way as `eCipher`, however the key is generated by swapping the `sRnd` and `time` variables when appending them to the `NSMutableData` object to HMAC. 

***

## `-[AylaEncryption:hmacForKey:data:]`
checks if first param (bLanKey in this case) is 0 if so initalize with empty string

stores bLanKey bytes and length in `key` and `keyLength` variables
stores data bytes and length in `data` and `bytes` variables

calls `CCHmac(kCCHmacAlgSHA256, key, keyLength, data, dataLength, &result)`
allocates a new `NSData` object and initalizes it with bytes from result.  
returns `NSData` object





